"""Interface e classes para suporte a agentes hier√°rquicos com sub-especialistas."""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from subagents.base_subagent import BaseSubagent

logger = logging.getLogger(__name__)


@dataclass
class SubSpecialtyRule:
    """Regra para delega√ß√£o para sub-especialistas."""
    name: str
    target_subagent: str
    keywords: List[str]
    description: str
    confidence_threshold: float = 0.3
    priority: int = 1  # Maior n√∫mero = maior prioridade


class HierarchicalAgent(ABC):
    """Interface para agentes que podem ter sub-agentes especializados."""
    
    def __init__(self):
        self.sub_agents: Dict[str, 'BaseSubagent'] = {}
        self.subspecialty_rules: List[SubSpecialtyRule] = []
        self.delegation_history: List[str] = []
    
    def register_sub_agent(self, sub_agent: 'BaseSubagent') -> None:
        """Registra um sub-agente especializado."""
        identifier = sub_agent.config.identifier
        self.sub_agents[identifier] = sub_agent
        logger.info(f"Sub-agente registrado: {identifier} sob {self.__class__.__name__}")
    
    def add_subspecialty_rule(self, rule: SubSpecialtyRule) -> None:
        """Adiciona regra de sub-especializa√ß√£o."""
        self.subspecialty_rules.append(rule)
        # Ordena por prioridade (maior n√∫mero primeiro)
        self.subspecialty_rules.sort(key=lambda r: r.priority, reverse=True)
    
    def find_best_subagent(self, query: str) -> Tuple[Optional[str], float]:
        """Encontra o melhor sub-agente para uma pergunta."""
        best_match = None
        best_score = 0.0
        
        query_lower = query.lower()
        print(f"üîé Analisando palavras-chave em: '{query_lower}'")
        logger.debug(f"Analisando query: '{query_lower}'")
        
        for rule in self.subspecialty_rules:
            # Calcula score baseado nas keywords
            matches = 0
            matched_keywords = []
            
            for keyword in rule.keywords:
                if keyword.lower() in query_lower:
                    matches += 1
                    matched_keywords.append(keyword)
            
            if matches > 0:
                # Score baseado no n√∫mero de matches e peso das palavras
                score = matches / len(rule.keywords)
                
                print(f"üìù Regra '{rule.target_subagent}': {matches} matches {matched_keywords}, score: {score:.3f}")
                logger.debug(f"Regra '{rule.name}': {matches} matches {matched_keywords}, score: {score:.3f}, threshold: {rule.confidence_threshold}")
                
                if score >= rule.confidence_threshold and score > best_score:
                    best_match = rule.target_subagent
                    best_score = score
                    print(f"üéØ Nova melhor op√ß√£o: {best_match} (score: {score:.3f})")
                    logger.debug(f"Nova melhor op√ß√£o: {best_match} (score: {score:.3f})")
        
        logger.info(f"Delega√ß√£o hier√°rquica: '{query[:50]}...' -> {best_match} (score: {best_score:.3f})")
        return best_match, best_score

    def find_top_candidates(self, query: str, top_k: int = 3) -> List[Tuple[str, float]]:
        """
        Encontra os top-k candidatos para fallback chain.
        
        Args:
            query: Pergunta do usu√°rio
            top_k: N√∫mero m√°ximo de candidatos a retornar
            
        Returns:
            Lista ordenada de (agente, score) por score decrescente
        """
        candidates = []
        query_lower = query.lower()
        
        print(f"üîç Analisando query: '{query_lower}'")
        print(f"üìã Total de regras: {len(self.subspecialty_rules)}")
        
        for rule in self.subspecialty_rules:
            matches = 0
            matched_keywords = []
            
            for keyword in rule.keywords:
                if keyword.lower() in query_lower:
                    matches += 1
                    matched_keywords.append(keyword)
            
            if matches > 0:
                score = matches / len(rule.keywords)
                print(f"üéØ Regra '{rule.name}' ‚Üí {matches} matches, score: {score:.3f}, threshold: {rule.confidence_threshold}")
                print(f"   Keywords matched: {matched_keywords}")
                
                if score >= rule.confidence_threshold:
                    candidates.append((rule.target_subagent, score))
                    print(f"   ‚úÖ Adicionado candidato: {rule.target_subagent}")
                else:
                    print(f"   ‚ùå Score abaixo do threshold")
            else:
                print(f"‚ö™ Regra '{rule.name}' ‚Üí 0 matches")
        
        # Ordenar por score decrescente e pegar os top-k
        candidates.sort(key=lambda x: x[1], reverse=True)
        print(f"üèÜ Candidatos finais: {candidates}")
        return candidates[:top_k]
    
    @abstractmethod
    def process_with_hierarchy(self, query: str, user_profile: Dict) -> str:
        """Processa pergunta considerando hierarquia de sub-agentes."""
        pass


class TIHierarchicalAgent(HierarchicalAgent):
    """Agente de TI com capacidade hier√°rquica."""
    
    def __init__(self, base_agent: 'BaseSubagent'):
        super().__init__()
        self.base_agent = base_agent
        self._setup_default_rules()
    
    def _setup_default_rules(self) -> None:
        """Configura regras padr√£o de sub-especializa√ß√£o para TI."""
        
        # Governance - Pol√≠ticas, compliance, seguran√ßa
        governance_rule = SubSpecialtyRule(
            name="governance_delegation",
            target_subagent="governance",
            keywords=[
                # Portugu√™s
                "pol√≠tica", "compliance", "auditoria", "seguran√ßa", "lgpd",
                "iso", "itil", "governan√ßa", "riscos", "controle", "norma",
                "certifica√ß√£o", "procedimento", "regulamenta√ß√£o", "27001",
                "assinatura", "assinaturas", "eletr√¥nica", "digital", "valida√ß√£o",
                "senhas", "senha", "autentica√ß√£o", "conformidade",
                # Ingl√™s
                "policy", "policies", "governance", "compliance", "audit", "security",
                "regulation", "standard", "certification", "procedure", "risk",
                "control", "signature", "signatures", "sign", "electronic", "digital",
                "validation", "password", "passwords", "authentication", "regulatory",
                # Espanhol
                "pol√≠tica", "pol√≠ticas", "gobernanza", "cumplimiento", "auditor√≠a",
                "firma", "firmas", "electr√≥nica", "validaci√≥n", "contrase√±a"
            ],
            description="Quest√µes de governan√ßa, compliance e pol√≠ticas de TI",
            confidence_threshold=0.03,  # Threshold ainda mais baixo para captar melhor
            priority=3
        )
        
        # Infraestrutura - Servidores, redes, hardware
        infra_rule = SubSpecialtyRule(
            name="infra_delegation",
            target_subagent="infra",
            keywords=[
                "servidor", "rede", "hardware", "datacenter", "backup",
                "disaster", "recovery", "uptime", "monitoramento", "capacidade",
                "performance", "storage", "virtualiza√ß√£o", "cloud", "aws", "status"
            ],
            description="Quest√µes de infraestrutura e opera√ß√µes",
            confidence_threshold=0.05,  # Threshold mais baixo
            priority=2
        )
        
        # Desenvolvimento - Aplica√ß√µes, sistemas, projetos
        dev_rule = SubSpecialtyRule(
            name="dev_delegation",
            target_subagent="dev",
            keywords=[
                "desenvolvimento", "aplica√ß√£o", "sistema", "c√≥digo", "projeto",
                "bug", "feature", "deploy", "release", "api", "banco", "dados",
                "integra√ß√£o", "teste", "homologa√ß√£o", "produ√ß√£o", "aplica√ß√£o"
            ],
            description="Quest√µes de desenvolvimento e sistemas",
            confidence_threshold=0.05,  # Threshold mais baixo
            priority=1
        )
        
        # Suporte ao Usu√°rio Final - Senha, login, ferramentas b√°sicas
        enduser_rule = SubSpecialtyRule(
            name="enduser_delegation",
            target_subagent="enduser",
            keywords=[
                "senha", "login", "acesso", "reset", "email", "outlook",
                "word", "excel", "teams", "usuario", "conta", "perfil",
                "suporte", "help", "ajuda", "como usar", "tutorial"
            ],
            description="Quest√µes de suporte ao usu√°rio final e ferramentas b√°sicas",
            confidence_threshold=0.05,
            priority=4  # Maior prioridade para quest√µes de usu√°rio
        )
        
        self.add_subspecialty_rule(enduser_rule)  # Adicionar primeiro (maior prioridade)
        self.add_subspecialty_rule(governance_rule)
        self.add_subspecialty_rule(infra_rule)
        self.add_subspecialty_rule(dev_rule)
    
    def _is_generic_response(self, response: str) -> bool:
        """Verifica se a resposta √© gen√©rica (indica que o agente n√£o encontrou dados espec√≠ficos)."""
        generic_indicators = [
            "n√£o localizei informa√ß√µes espec√≠ficas sobre",
            "n√£o localizei essa informa√ß√£o espec√≠fica",
            "n√£o tenho informa√ß√µes espec√≠ficas",
            "n√£o encontrei dados espec√≠ficos",
            "preciso de mais informa√ß√µes",
            "n√£o possuo dados detalhados",
            "n√£o encontrei essa informa√ß√£o",
            "n√£o tenho acesso a essa informa√ß√£o",
            "informa√ß√µes n√£o dispon√≠veis",
            "dados n√£o encontrados",
            "n√£o consta em nossa base",
            "n√£o foi poss√≠vel localizar",
            "n√£o possuo informa√ß√µes sobre",
            "n√£o h√° dados dispon√≠veis",
            "informa√ß√£o n√£o encontrada",
            "desculpe, mas n√£o encontrei",
            "lamento, mas n√£o possuo"
        ]
        
        response_lower = response.lower()
        is_generic = any(indicator in response_lower for indicator in generic_indicators)
        
        # Debug logging para acompanhar detec√ß√£o
        if is_generic:
            print(f"üîç Resposta gen√©rica detectada: '{response[:100]}...'")
        
        return is_generic
    
    def _get_delegation_reason(self, query: str, agent_type: str, score: float) -> str:
        """Explica o motivo da delega√ß√£o para transpar√™ncia."""
        query_lower = query.lower()
        
        reasons = {
            'governance': {
                'keywords': ['regulamenta√ß√£o', 'anvisa', 'pol√≠tica', 'compliance', 'seguran√ßa', 'auditoria', 'norma', 'lei', 'decreto'],
                'description': 'Especialista em regulamenta√ß√µes, pol√≠ticas e compliance'
            },
            'infrastructure': {
                'keywords': ['servidor', 'rede', 'infraestrutura', 'hardware', 'sistema', 'performance'],  
                'description': 'Especialista em infraestrutura e sistemas'
            },
            'dev': {
                'keywords': ['desenvolvimento', 'c√≥digo', 'programa√ß√£o', 'api', 'software', 'aplica√ß√£o'],
                'description': 'Especialista em desenvolvimento de software'
            },
            'enduser': {
                'keywords': ['usu√°rio', 'interface', 'suporte', 'treinamento', 'manual', 'tutorial'],
                'description': 'Especialista em suporte ao usu√°rio final'
            }
        }
        
        if agent_type in reasons:
            agent_info = reasons[agent_type]
            matched_keywords = [kw for kw in agent_info['keywords'] if kw in query_lower]
            
            if matched_keywords:
                return f"{agent_info['description']}. Palavras-chave identificadas: {', '.join(matched_keywords)}"
            else:
                return f"{agent_info['description']}. Score de relev√¢ncia: {score:.3f}"
        
        return f"Agente com maior score de relev√¢ncia ({score:.3f}) para esta consulta"
    
    def process_with_hierarchy(self, query: str, user_profile: Dict) -> str:
        """Processa pergunta usando hierarquia de sub-especialistas com fallback chain."""
        
        # Inicializar cadeia de decis√£o para transpar√™ncia
        decision_chain = []
        decision_chain.append(f"üîç **An√°lise inicial**: TI Hierarchy analisando pergunta sobre '{query[:50]}...'")
        
        # 1. Obter top 3 candidatos para fallback chain
        candidates = self.find_top_candidates(query, top_k=3)
        
        if candidates:
            candidate_info = [(agent, f'{score:.3f}') for agent, score in candidates]
            decision_chain.append(f"üéØ **Candidatos identificados**: {candidate_info}")
            decision_chain.append("üìä **Crit√©rio de sele√ß√£o**: Relev√¢ncia por palavras-chave e especialidade")
            
            # 2. Tentar cada candidato em ordem de score
            for i, (candidate_agent, score) in enumerate(candidates):
                if candidate_agent not in self.sub_agents:
                    continue
                    
                sub_agent = self.sub_agents[candidate_agent]
                
                # Log da delega√ß√£o com motivo
                delegation_reason = self._get_delegation_reason(query, candidate_agent, score)
                decision_chain.append(f"üîÑ **Tentativa #{i+1}**: Delegando para **{sub_agent.config.name}** (score: {score:.3f})")
                decision_chain.append(f"üí° **Motivo**: {delegation_reason}")
                
                logger.info(f"üîÑ TI delegando para sub-especialista: {sub_agent.config.name}")
                
                try:
                    # Processa com o sub-agente especializado
                    print(f"ü§ñ Chamando {sub_agent.config.name} (tabela: {sub_agent.config.table_name})")
                    result = sub_agent.processar_pergunta(query, user_profile)
                    
                    print(f"üìù {sub_agent.config.name} retornou {len(result)} caracteres")
                    print(f"üîç Primeiros 100 chars: '{result[:100]}...'")
                    
                    # Verificar se o resultado √© gen√©rico (indica que n√£o achou dados)
                    if self._is_generic_response(result):
                        print(f"üîç Resposta detectada como gen√©rica por {sub_agent.config.name}")
                        decision_chain.append(f"‚ùå **Resultado**: {sub_agent.config.name} n√£o encontrou informa√ß√µes espec√≠ficas")
                        if i < len(candidates) - 1:  # Se n√£o √© o √∫ltimo candidato
                            decision_chain.append("‚ö° **A√ß√£o**: Tentando pr√≥ximo especialista na hierarquia...")
                        continue
                    
                    # Sucesso! Adiciona cadeia de decis√£o transparente
                    decision_chain.append(f"‚úÖ **Sucesso**: {sub_agent.config.name} encontrou informa√ß√µes relevantes!")
                    
                    # Montar resposta com transpar√™ncia completa
                    transparency_section = "\n\n" + "="*60 + "\n"
                    transparency_section += "üß† **CADEIA DE DECIS√ÉO E RACIOC√çNIO**\n"
                    transparency_section += "="*60 + "\n"
                    for step in decision_chain:
                        transparency_section += f"{step}\n"
                    
                    transparency_section += f"\nüìã **Resposta final fornecida por**: {sub_agent.config.name} ({sub_agent.config.specialty})"
                    if i > 0:
                        transparency_section += f"\nüîÑ **Redirecionamentos**: {i} tentativa(s) anteriores"
                    transparency_section += "\nüéØ **Coordenado por**: Sistema TI Hier√°rquico"
                    transparency_section += "\n" + "="*60
                    
                    self.delegation_history.append(f"{query[:50]}... -> {candidate_agent}")
                    
                    return result + transparency_section
                    
                except Exception as e:
                    logger.error(f"Erro no sub-agente {candidate_agent}: {e}")
                    print(f"‚ùå Erro em {sub_agent.config.name}, tentando pr√≥ximo...")
                    continue
        else:
            decision_chain.append("‚ùì **Resultado da an√°lise**: Nenhum especialista espec√≠fico identificado")
            decision_chain.append("üîÑ **A√ß√£o**: Redirecionando diretamente para TI geral")
        
        # 3. Se nenhum candidato funcionou, usar TI principal
        decision_chain.append("‚ùå **Resultado**: Nenhum especialista encontrou informa√ß√µes espec√≠ficas")
        decision_chain.append("üîÑ **Fallback final**: Redirecionando para agente TI geral")
        
        logger.info("ü§ñ TI processando com conhecimento geral")
        result = self.base_agent.processar_pergunta(query, user_profile)
        
        # Montar transpar√™ncia para fallback final
        transparency_section = "\n\n" + "="*60 + "\n"
        transparency_section += "üß† **CADEIA DE DECIS√ÉO E RACIOC√çNIO**\n"
        transparency_section += "="*60 + "\n"
        for step in decision_chain:
            transparency_section += f"{step}\n"
        
        transparency_section += f"\nüìã **Resposta final fornecida por**: {self.base_agent.config.name} (TI Geral)"
        transparency_section += "\n‚ö†Ô∏è **Motivo**: Especialistas n√£o encontraram informa√ß√µes espec√≠ficas"
        transparency_section += "\nüéØ **Coordenado por**: Sistema TI Hier√°rquico"
        transparency_section += "\n" + "="*60
        
        return result + transparency_section
    
    def get_hierarchy_stats(self) -> Dict:
        """Retorna estat√≠sticas da hierarquia."""
        return {
            "sub_agents_count": len(self.sub_agents),
            "sub_agents": list(self.sub_agents.keys()),
            "rules_count": len(self.subspecialty_rules),
            "delegations_history": len(self.delegation_history),
            "recent_delegations": self.delegation_history[-5:] if self.delegation_history else []
        }
